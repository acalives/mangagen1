
# Manga-Gen: AI-Powered Manga Creator

Manga-Gen is a web-based application that uses Google's Gemini AI to create manga-style comics from text prompts. It handles everything from story generation to panel layout and illustration.

## 1. High-Level Architecture

The application is a **fully client-side React web app**. This means that all the logic—from making AI calls to handling user interactions—runs directly in your web browser. There is no backend server.

Think of it as a digital assembly line:

1.  **The User** provides a creative brief (the story prompt).
2.  **The Scriptwriter (AI)** generates a detailed story plan and panel layout.
3.  **The Illustrator (AI)** draws the artwork for each panel based on the plan.
4.  **The Typesetter (React)** assembles the artwork and text on the page.
5.  **The Editor (You)** makes final adjustments to the layout and text.
6.  **The Publisher** packages the final pages for download.

---

## 2. Tech Stack Breakdown

Here are the core technologies used and their specific roles:

### Frontend Framework & Language

*   **React (v18+)**: The backbone of the application. It manages the user interface, rendering components like the prompt form, manga pages, and panels. Its hook-based architecture (`useState`, `useEffect`, `useCallback`) is used to manage the application's state (e.g., the list of generated pages, loading status).
*   **TypeScript**: Provides static typing for all the JavaScript code. This ensures that data structures (like `Story`, `MangaPanel`, etc.) are consistent throughout the app, which prevents bugs and makes the code easier to maintain.

### Styling

*   **Tailwind CSS**: A utility-first CSS framework used for all styling. It allows for rapid development of a modern, responsive, and aesthetically pleasing UI directly within the JSX of the components, without writing separate CSS files.

### AI & Generative Services

*   **Google Gemini API (`@google/genai`)**: The creative engine of the application. We use two different models for distinct tasks:
    *   **`gemini-2.5-flash` (The Scriptwriter)**: This text-based model is used for narrative generation. We give it a highly structured prompt and a JSON schema, and it returns a complete, machine-readable story plan (`Story` object). This plan includes the synopsis, character descriptions, and a chronological sequence of `PlotNode` objects, each containing a visual description and suggested geometry for text boxes.
    *   **`imagen-4.0-generate-001` (The Illustrator)**: This image generation model is used to create the artwork for each panel. It receives a very specific, tag-based prompt that details the content, style, mood, and—most importantly—the exact number of characters to draw, along with a strong "negative prompt" to prevent it from drawing text or anatomical errors.

### Core Features & Libraries

*   **`html2canvas`**: A library that can take a "screenshot" of any HTML element on the page and convert it into a canvas image. We use this in the "Download" feature to capture the final, user-edited manga pages.
*   **`jszip`**: A library for creating, reading, and editing `.zip` files. In the "Download" feature, it takes the images generated by `html2canvas` and packages them into a single, convenient `.zip` archive for the user.

### Build & Deployment

*   **`build.bat` / `build.sh`**: These are simple build scripts for Windows and Linux/macOS, respectively. Their **only job** is to inject the `API_KEY` environment variable into the `geminiService.ts` file before deployment. This creates a `dist` folder with the final, deployable application files.
*   **Static Hosting (e.g., Netlify, Vercel)**: The application is designed to be hosted on any static file server. The deployment guide recommends Netlify because it provides an easy way to manage environment variables (`API_KEY`) and automatically run the build script.

---

## 3. Local Development & Setup

To run this application on your own computer, you must serve the files using a local web server. You cannot simply open `index.html` in your browser due to security restrictions related to JavaScript Modules.

**For detailed, step-by-step instructions, please see the [LOCAL_DEVELOPMENT.md](./LOCAL_DEVELOPMENT.md) file.**

For answers to common questions about the setup (like whether you need to install packages), see the **[FAQ.md](./FAQ.md)** file.

---

## 4. The Workflow: How It All Works Together

This is a step-by-step trace of the entire process, from prompt to final product.

#### **Step 1: User Input**
1.  You type a story idea into the `PromptForm.tsx` component.
2.  You click "Generate". This triggers the `generateManga` function inside the `useMangaGenerator.ts` hook.

#### **Step 2: Story Generation (The Scriptwriter)**
1.  `useMangaGenerator` calls `geminiService.generateStory()`.
2.  `geminiService` sends your prompt to the **`gemini-2.5-flash`** model with a strict system instruction and a JSON schema.
3.  The AI returns a structured JSON object containing the entire story, including the `plotNodes` array. Each node has a visual description and `suggestedGeometry` for text boxes.
4.  The hook saves this `Story` object in its state and uses it to create an initial set of `MangaPage` and `MangaPanel` objects, with loading spinners for the images.

#### **Step 3: Image Generation (The Illustrator)**
1.  The `generateManga` function then loops through each `plotNode`.
2.  For each node, it calls `geminiService.generatePanelImage()`, passing the visual description, character details, and mood.
3.  `geminiService` constructs a highly specific, tag-based prompt and sends it to the **`imagen-4.0-generate-001`** model.
4.  The model returns a base64-encoded image.
5.  The hook updates the state with the new image URL for the corresponding panel, which causes React to replace the loading spinner with the generated artwork.

#### **Step 4: Interactive Editing (The Editor)**
1.  The UI is rendered by `MangaPanel.tsx`, which places `DraggableResizable` components for each dialogue and narration box.
2.  **Moving**: When you click and drag a text box, `DraggableResizable.tsx` captures the mouse events, calculates the new `x` and `y` coordinates as percentages, and calls the `onUpdate` function.
3.  **Resizing**: When you drag the resize handle, it does the same for `width` and `height`.
4.  **Editing Text/Font**: When you edit text or change the font size, the `EditableText` or `DraggableResizable` component calls its respective update handler.
5.  All these updates bubble up to the `useMangaGenerator` hook's `updatePanel` function, which updates the main `mangaPages` state. React then re-renders the component with your changes applied.

#### **Step 5: Saving and Loading**
-   **Save**: The `saveManga` function takes the current `story` and `mangaPages` objects from the state, converts them to a JSON string, and downloads it as a `.json` file.
-   **Load**: The `loadManga` function reads a user-selected `.json` file, parses it, and uses the data to overwrite the `story` and `mangaPages` state, restoring your session.

#### **Step 6: Downloading the Manga**
1.  You click the "Download" button in the `Header`. This calls the `downloadManga` function.
2.  The function finds all manga page elements on the screen (using the `.manga-page-container` class).
3.  It iterates through them, using **`html2canvas`** to render each page's HTML (including the image and your edited text boxes) into a PNG image.
4.  Each PNG is added to a new zip archive using **`jszip`**.
5.  Once all pages are processed, `jszip` generates the final `.zip` file, and the browser automatically downloads it for you.
